Type Less do More:
	semicolons:
		treats end-of-line as end of statements or an expression
		can use semicolons if multiple statements are in the same line
		case clause need not be covered with curly braces
			case a => 
				println
				exit	
	
	variable declarations:
		immutable variable is declared with val
			must be initialized when declared
		mutable variable is declared with var
			array reference cannot be changed to point to a different array, but it can be change
		immutable is consistent with the principles of pure functional programming
	
	method declarations
		sequence
			- start with a def keyword
			- optional argument list
			- colon character
			- return type
			- equal sign
			- method body
		if a method body has more than one expression, should be surrounded with curly braces
		if a method body has only one expression, curly braces can be omitted
		
		method default and named arguments
			default values for parameters can be defined
				def function(param1: type, param2: String = " "): Unit = {}
				can declare
					def join(first: String , second: String = "not given"): Unit = println("hello " + first + second)
				and call
					join("murali") will give hello murali not given
			named arguments
				name of the variable can be mentioned when calling the method
				advantages
					- the names suggests the purpose of the parameters
					- the order of the params can be changed when they are named
				can call
					join(second="venu", first="murali")
				limitations: once a parameter is named, the following parameters should also be named
		nesting method definitions
			methods can be inside methods
			a nesed method is only visible inside the enclosed method
			variables shadowing and maksing applies to nested methods

		type inference
			scala supports type inference
			there is not need to specify type signatures for variables and method return types
				val age=32, val name="murali" will automatically find their types
			still, type annotations has to be used for explicit type declarations like HashMap<Integer, String>
			still, method parameters should be annotated with types, that's why local type inference
			explicit type annotations should be provided for the following scenarios
				- variable declared without initializing, var name: String, var age: Int
				- all method parameters
				- method return types should be annotated, if
					- when u explicitly call return in a method
					- when a method is recursive
					- when a method is overloaded and one fo the method is calling other
				- when is inferred type is more general than you inteded, eg Any
		literals
			defn: literals is a notation for representing fixed values in source code. eg. constants
			integer literals
				- decimal : 0 or a non-zero digit followed by zero or more digits 0-9 eg: 0, 23, 213
				- hexa decimal: 0x followed by one or more hexa decimal digits 0-9 A-F a-f eg: 0xaf83 
				- octal: 0 followed by one or more octal digits 0-7 eg: 034
			float literals
				integer followed by . followed by integer
				Float is a 32 bit single precision binary floating-point values
				Double is a 64 bit double precision binary floating-point values
			boolean literals
				true or false
			character literals
				is either a printable unicode character or an escape sequence, within single quotes
				'A', '\n'
				\b \u0008 Backspace (BS)
					\t \u0009 Horizontal tab (HT)
					\n \u000a Line feed (LF)
					\f \u000c Form feed (FF)
					\r \u000d Carriage return (CR)
					\" \u0022 Double quote (")
					\’ \u0027 Single quote (’)
					\\ \u0009 Backslash (\)
			string literals
				either enclosed in double or triple quotes
				double quotes: should escapte special characters
				triple quotes: need not escapte them, can be just part of the string
			symbol literals
				is a single quote followed by a letters and followed by digits eg: 'a
		
		tuples
			grouping of two or more items
			commma separated within paranthesis eg: (x1, x2,...., x22)
			type of elements can be mixed of different types
			class of type scala.TupleN, where N is number of items in tuples
			N can range from 1 to 22, cannot be 0
			tuples are immutable
			eg:
				def tupleator(x1: Any, x2: Any, x3: Any) = (x1, x2, x3)
				val t = tupleator("hi", !, 2.33), will assign t the whole tuple
				val t(t1, t2, t3) = tupleator("hi", !, 2.33), will extract the tuples and assing to t1, t2 and t3 directly
			ways to define tuple
				-> can be used also: 1 -> 2 will give (1,2)
				Typle2(1,2)
				Pair(1,2)

		Option, Some and None
			Option is the parent class, Some and None are child classes
			java returns null when there is nothing to return, but null is a keyword not an object. so no method can be called.
			why return keyword when an object is expected
			when there is no value use None, where thers is a values use Some, which wraps the value
			None is declared as an Object, singleton.
			Collections by default returns Option type, but it doesn't store Option, it just wraps the value into Options (Some/None) upon retrivel
			using getOrElse returns the value Option if it's a Some instance or will return the second argument passed to getOrElse it it's None
		
		Organizing code: Files and Namespaces
			File name doesn't have to match the type names
			package structure doesn't have to match the directory structure
			eg:
				package murali {
					package messages {
						package send {
							case class request(name: String)
						}
						package receive {
							case class response(age: Int)
						}
					}	
				}
				the code can be saved in a file called "test.scala"
			methods in packages can refer packages and classes from it's siblings
		
		Importing types and their members
			import java.awt._ - import all types in the package using _ as a wildcard
			import java.io.File - import individual type by specifying it's name
			import java.io.File._ - import all the static methods and fields, bascially a static import
			import java.util.{HashMap, Map} - import only specific types in a package instead of all
			features:
				we can put import statement almost anywhere
				imports can be made within a functions, which cannot be accessed out of the block
					this puts the import statement more closer to its usage
				imports can be renamed
				eg:
					def test = {
						import java.math.BigInteger {
							ONE => _, // makes it invisible in the import scope, ie. ONE is not imported
							TEN, // no renaming is done
							ZERO => javazero // aliased
						}
					}
			imports are relative
				import scala.collections.mutable._
				import collections.immutable._ // since scala is already imported
				package scala.actors {
					import remote._
				} // we are in the scope of scala actors
			instead of relative, to use absolute path use _root_.
		
		Abstract and Parameterized types
			Java generics intro:
				Generic methods: a single method that will accept more than one type of parameters
				Bounded type parameters: a method that will accept only paraemters of certain types. Like Integers and it's sub types (Float, Double,Long, Short) and not String
				Generic class: // not clear
			difference between java and scala
				java calls it generics", scala calls it "paramerized types"
				java uses angle brackes <>, scala uses square brackes []
				in/co/contra variance supported // #### need to be looked into
			abstract class // #### need to be looked into
		
		reserved keywords
			break and continue are not used in scala // have to find it
			

Rounding out the essentials
	Operators are methods in scala
		all operators are actually methods
		scala allows non-alphanumeric method names
		exclusions are:
			parenthetical characters () {} []
			delimeter characters ` ' " . ; ,
			reserved keywords cannot be used
			pattern matching
				token begining with lower case are parsed as variable identifiers
        token begining with upper case are parased as constant identifiers

	Syntactic sugar
		! is just an other method
		\ and \\ are just methods in scala.xml.NodeSeq

	Method without paranthesis and donts
		if a method takes no parameters, it can be called without paranthesis
		when calling a method without or with one parameter the prefixing dot can be avoided
		Operator precedence
		all letters, |, ^, &, <>, =!, :, +-, */%

	if statements
		if is an expression itself, hence will return a value
			eg; val path = if (file.exists()) {
					get path }
				else {
					create file
					get path }
			path will have the value of the file path
			using path again will not evaluate the if expression again
	for comprehansion
		for (breed <- dogbreed)
			println(breed)
		<- , left-arrow operator is called generator, cos it is generating individual values breed from collection dogbreed
		filtering
			for (breed <- dogbreed if breed.contains("lab")) println(breed)
				to add more than one filter, separate them with semicolons
		yielding
			yield keyword generates new collections with the for comprehension
			val breeds = for {breed <- dogbreed} yield breed
				here, every loop of for will return breed which will be accumulated as a list in breeds
			type of the yield collections is of type iterated collection
			for expressions can be defined with
				paranthesis - semicolon is required to delimit filters
				curl braces - semicolon is not required to delimit filters
		expanded scope
			for {
				breed <- dogbreeds
				upcasebreed = breed.toUpperCase()
				} prinln upcasebreed
			here, upcasebreed need not be declared and its available within the scope of the for block
	Other looping constructs
		while loops
